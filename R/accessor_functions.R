# #Accessor functions

#' Helper to search levels for top_level_group
#'
#' Internal Helper to search levels for top_level_group. Used by
#' [.GET_table_generic], [GET_pairwise_plots]
#'
#' @param list_of_objects List of objects that's named. This is what is
#'   searched. Inherited from other functions.
#' @param search_term character vector of top_level_groups (see
#'   [auto_generate_DE_results]) to search for, returning only list entries from
#'   these groups. e.g. \code{c("ARC","LIV")}. Inherited from other functions.
#' @param pattern_extract_top_level string representing a regex match to return
#'  the names of the top level. Default works for all accessors from DE output.
#'  RIF requires unique.
#'
#' @return Returns a filtered list.

.search_list_helper <-
  function(list_of_objects,
           search_term,
           pattern_extract_top_level = "^[^_]*"){

    #get top level name options and check search_top_level is one of them
    names_in_list <-  names(list_of_objects) %>%
      stringr::str_extract(pattern = pattern_extract_top_level)

    if(is.null(search_term)){
      return(list_of_objects)
    } else {
      #Create regex search terms - handles 1 or more provided by c()
      regex_term <-
        stringr::str_c("^",search_term,"$") %>% #anchors for whole words
        stringr::str_c(collapse = "|") #sep by | to match all entries

      search_l <-  stringr::str_detect(names_in_list, regex_term)

      if(all(!search_l)){
        stop(paste("'search_top_level' does not match any names in top level. Possible options are:",
                   paste(paste0("\"",unique(names_in_list), "\" "), collapse = ", ")))
      } else {

        return(list_of_objects[search_l])

      }
    }
  }



#' GET tables
#'
#' Internal accessor function that maps over the DE list output from
#' [auto_generate_DE_results]. Used by [GET_PIF_df], [GET_DE_by_PIF_df]
#' and others.
#'
#' @param map_string character string that matches element names in the
#' auto_DE_output. Normally this is set by other functions.
#' @param DE_output object (class = list) returned from a call to
#'   [auto_generate_DE_results]
#' @param search_top_level character vector of top_level_groups (see
#'   [auto_generate_DE_results]) to search for, returning only tables from these
#'   groups. e.g. \code{c("ARC","LIV")}. If not provided it will return all DE
#'   tables.
#'
#' @return Returns a list of 1 level with all DE tables.
#'

.GET_table_generic <- function(map_string,
                               DE_output,
                               search_top_level = NULL){

  if(!is.character(map_string)){
    stop("'map_string' must be a character string")
  }

  dataframes <-
    DE_output %>%
    purrr::map(map_string) %>%
    unlist(recursive = FALSE)

  .search_list_helper(search_term = search_top_level,
                      list_of_objects = dataframes)

}


#' GET PIF tables
#'
#' Accessor function to access all genes with DE and PIF values, generated by
#' [auto_generate_DE_results]. Useful to prepare data for input to
#' [auto_plot_multi_MA] or [plot_custom_MA].
#'
#'
#' @param auto_DE_output object (class = list) returned from a call to
#'   [auto_generate_DE_results]
#' @param search_top_level character vector of top_level_groups (see
#'   [auto_generate_DE_results]) to search for, returning only tables from these
#'   groups. e.g. \code{c("ARC","LIV")}. If not provided it will return all DE
#'   tables.
#'
#' @return Returns a list of 1 level with all DE tables.
#'
#' @export
#'
GET_PIF_df <-
  function(auto_DE_output, search_top_level = NULL){

    if(is.null(search_top_level)){
      .GET_table_generic("PIF",
                         auto_DE_output)
    } else {
      .GET_table_generic("PIF",
                         auto_DE_output,
                         search_top_level)
    }
}


#' GET DE tables
#'
#' Accessor function to access DE tables, sorted by PIF value, generated by
#' [auto_generate_DE_results]
#'
#'
#' @param auto_DE_output object (class = list) returned from a call to
#'   [auto_generate_DE_results]
#' @param search_top_level character vector of top_level_groups (see
#'   [auto_generate_DE_results]) to search for, returning only tables from these
#'   groups. e.g. \code{c("ARC","LIV")}. If not provided it will return all DE
#'   tables.
#'
#' @return Returns a list of 1 level with all DE tables.
#'
#' @export
#'
GET_DE_by_PIF_df <-
  function(auto_DE_output,
           search_top_level  = NULL){
    if(is.null(search_top_level)){
      .GET_table_generic("DE_by_PIF_df",
                         auto_DE_output)
    } else {
      .GET_table_generic("DE_by_PIF_df",
                         auto_DE_output,
                         search_top_level)
    }
  }

#' GET normalised counts tables
#'
#' Accessor function to access normalised counts tables for each top_level_group
#' individually, as generated by [auto_generate_DE_results]. These are generally
#' not useful, and downstream applications of RIF and PCIT, etc should use
#' the counts normalised across whole dataset.
#'
#'
#' @param auto_DE_output object (class = list) returned from a call to
#'   [auto_generate_DE_results]
#' @param search_top_level character vector of top_level_groups (see
#'   [auto_generate_DE_results]) to search for, returning only tables from these
#'   groups. e.g. \code{c("ARC","LIV")}. If not provided it will return all DE
#'   tables.
#' @param vst_or_log2 character vector of either: "VST", "Log2", "both"
#'
#' @return Returns a list of dataframes
#'
#' @export


GET_normalised_data <-
  function(auto_DE_output,
           search_top_level = NULL,
           vst_or_log2 = c("VST", "Log2", "both")){

    if(is.null(search_top_level)){
     out <-  .GET_table_generic("normalised_data",
                         auto_DE_output)
    } else {
      out <- .GET_table_generic("normalised_data",
                         auto_DE_output,
                         search_top_level)
    }

    #Entry checks
    if(length(vst_or_log2) > 1){
      stop("length(type) > 1 - Select only ONE of either \"PCA\", \"heatmap\" or
           \"sample_distances\" ")
    } else if(!(vst_or_log2  %in% c("VST", "Log2", "both"))){
      stop("type must be ONE of either \"VST\", \"Log2\" or
           \"both\"")
    } else if(vst_or_log2 == "both"){
      return(out)

    } else if(vst_or_log2 == "VST"){
      search_l <-  stringr::str_detect(names(out), "vsd$")
      out <- out[search_l]
      return(out)

    } else if(vst_or_log2 == "Log2"){
      search_l <-  stringr::str_detect(names(out), "log2norm$")
      out <- out[search_l]
      return(out)

    }

  }

#' GET dds_wald objects
#'
#' Accessor function to the DESeqDataSet objects (derived from the
#' SummarizedExperiment object parsed to [auto_generate_DE_results]) after the
#' call to DESeq2 (via [auto_generate_DE_results]).
#'
#'
#' @param auto_DE_output object (class = list) returned from a call to
#'   [auto_generate_DE_results]
#' @param search_top_level character vector of top_level_groups (see
#'   [auto_generate_DE_results]) to search for, returning only tables from these
#'   groups. e.g. \code{c("ARC","LIV")}. If not provided it will return all objects.
#'
#' @return Returns a list of 1 level with all dds_wald objects
#' (of class DESeqDataSet)
#'
#' @export
#'
GET_dds_wald_objects <-
  function(auto_DE_output,
           search_top_level  = NULL){

    if(is.null(search_top_level)){
      .GET_table_generic("dds_wald_object",
                         auto_DE_output)
    } else {
      .GET_table_generic("dds_wald_object",
                         auto_DE_output,
                         search_top_level)
    }

  }


#' GET DESeq Results objects
#'
#' Accessor function to the results objects, containing all metadata, produced for
#' each pairwise comparison. Most useful for accessing advanced information on how
#' results were generated (via [auto_generate_DE_results]). This output is also
#' used by [enrich_DE].
#'
#'
#' @param auto_DE_output object (class = list) returned from a call to
#'   [auto_generate_DE_results]
#' @param search_top_level character vector of top_level_groups (see
#'   [auto_generate_DE_results]) to search for, returning only tables from these
#'   groups. e.g. \code{c("ARC","LIV")}. If not provided it will return all objects.
#'
#' @return Returns a list of 1 level with all DESeqResults objects
#'
#' @export

GET_DESeq2_res_object <-
  function(auto_DE_output,
           search_top_level  = NULL){

    if(is.null(search_top_level)){
      .GET_table_generic("DESeq2_res_object",
                         auto_DE_output)
    } else {
      .GET_table_generic("DESeq2_res_object",
                         auto_DE_output,
                         search_top_level)
    }
  }






GET_boxplot_cooks_distance <-
  function(auto_DE_output){
    plots_list <-
      auto_DE_output %>%
      purrr::map("boxplot_cooks_distance")


    print(plots_list)

    plots_list
  }


#' GET pairwise plots
#'
#' Accessor function to access one of three types of pairwise plots generated
#' by [auto_generate_DE_results]
#'
#'
#' @param auto_DE_output object (class = list) returned from a call to
#' [auto_generate_DE_results]
#' @param type one of either: "MA" or "Pvalue" for generic MA plots used for QC
#' or P value histograms, respectively.
#' @param search_top_level character vector of top_level_groups (see
#'   [auto_generate_DE_results]) to search for, returning only tables from these
#'   groups. e.g. \code{c("ARC","LIV")}. If not provided it will return all DE
#'   tables.
#'
#' @return Returns a list of 1 level with all plots of \code{type}. Also prints
#' plots, particularly useful in a RMarkdown code chunk.
#'
#' @export
GET_pairwise_plots <-
  function(auto_DE_output,
           type = c("MA", "Pvalue"),
           search_top_level = NULL
           ){

    #Entry checks
    if(length(type) > 1){
      stop("length(type) > 1 - Select only ONE of either \"MA\" or \"Pvalue\"")
    } else if(!(type %in% c("MA", "Pvalue"))){
      stop("type must be ONE of either \"MA\" or \"Pvalue\"")
    }

    #helper VIEW function
    .f_view_plots <-
      function(x){
        print(x)
        graphics::plot.new()
        grDevices::dev.off()
      }

    ########################### MA ###########################
    if(type == "MA"){
      MA_list <-
        auto_DE_output %>%
        purrr::map("pairwise_plots") %>%
        purrr::map('MA_plots') %>%
        .search_list_helper(search_term = search_top_level)

      purrr::map(MA_list, .f_view_plots)

      return(MA_list)

    } else if(type == "Pvalue"){
      ########################### Pvalue histograms ###########################
      Pvalue_histogram_list <-
        auto_DE_output %>%
        purrr::map("pairwise_plots") %>%
        purrr::map('Pvalue_histogram') %>%
        .search_list_helper(search_term = search_top_level)


      purrr::map(Pvalue_histogram_list, .f_view_plots)

      return(Pvalue_histogram_list)
    }
  }


#' GET overall plots
#'
#' Accessor function to access one of three types of overall plots generated
#' by [auto_generate_DE_results]
#'
#'
#' @param auto_DE_output object (class = list) returned from a call to
#' [auto_generate_DE_results]
#' @param type one of either: "PCA", "heatmap" or "sample_distances"
#'
#' @return Returns a list of 1 level with all plots of \code{type}. Also prints
#' plots, particularly useful in a RMarkdown code chunk.
#'
#' @export
GET_overall_plots <-
  function(auto_DE_output,
           type = c("PCA", "heatmap", "sample_distances")){

    #Entry checks
    if(length(type) > 1){
      stop("length(type) > 1 - Select only ONE of either \"PCA\", \"heatmap\" or
           \"sample_distances\" ")
    } else if(!(type %in% c("PCA", "heatmap", "sample_distances"))){
      stop("type must be ONE of either \"PCA\", \"heatmap\" or
           \"sample_distances\"")
    }

    #helper VIEW function
    .f_view_plots <-
      function(x){
      print(x)
      graphics::plot.new()
      grDevices::dev.off()
    }

    ########################### PCA ###########################
    if(type == "PCA"){
    PCA_list <-
      auto_DE_output %>%
      purrr::map("overall_plots") %>%
      purrr::map('PCA')


    print(PCA_list)

    return(PCA_list)

    } else if(type == "heatmap"){
    ########################### heatmaps ###########################
    heatmaps_list <-
      auto_DE_output %>%
      purrr::map("overall_plots") %>%
      purrr::map('heatmap')


    purrr::map(heatmaps_list, .f_view_plots)

    return(heatmaps_list)
    } else if(type == "sample_distances"){
    ########################### sample_dist_list ###########################
    samp_dist_list <-
      auto_DE_output %>%
      purrr::map("overall_plots") %>%
      purrr::map('Sample_distances')

    purrr::map(samp_dist_list, .f_view_plots)

    return(samp_dist_list)
    }
  }
