---
title: "Testing DESEQ2"
output: html_notebook
---

Iteration of DESEQ2 over: Region level, then treatment comparison

Region level - e.g. Tissue region, indicates all DE data from same tissue and experiment. These are analysed independently from every other region.

Within a region, the treatments are compared.


However, for downstream plotting, the normalised data from all regions is calculated. Particularly important for co-expression related analysis.


To normalise gene expression across all tissues, the 'DESEQ2 - all tissues - FULL - **' needs to be used.

#Step 1a in pipeline

```{r echo=F, warning = FALSE, message = FALSE}
library(plyr)
library(DESeq2)
library(data.table)
library(tidyverse)
library(RColorBrewer)
library(genefilter)
library(pheatmap)
library(gplots)
library(ggrepel)


library(SummarizedExperiment)
```


# 1. Import metadata
```{r}

#import data about columns, that is each column should be metadata about the sample/animal. Particularly include all treatment info and animal ID in columns. 
coldata <-  data.table::fread(file = "../Sheep_RNAseq/Inputs/coldata_new_names_20201105.csv") %>% 
  dplyr::mutate(sample_names = paste0(Region, "_", ID, "__", Diet))


```




# 2. import all count tables and join
```{r matrix_input, echo=T}


cts_all <- data.table::fread(file= "./cts_renamed_all_Sheep.txt")

###### ************
# Use new function
cts_filtered <- DE4Rumi::check_count_matrix(count_data = cts_all, 
                            colData = coldata,
                            column_with_col_names = sample_names
                            )
rm(cts_all)
```



# 3. convert ensemble ID to gene ID

```{r}

test_annot <- DE4Rumi::annotate_gene_ensembl(cts_filtered, organism = "oaries")
```


# Prepare data
```{r}


test_data <-
  SummarizedExperiment::SummarizedExperiment(assays = cts_filtered %>% tibble::column_to_rownames(var = "gene_ensembl") %>% as.matrix(),
                                             rowData = test_annot, 
                                             colData = coldata)
```



#4. Generate DE results
```{r}

DE_out <- auto_generate_DE_results(top_level_filter = "ARC", 
                 se_data = test_data,
                 top_level_name = Region,
                 column_of_samples = sample_names,
                 DESeq2_formula_design = ~Region_Diet,
                 rowSums_filter = 10,
                 results_contrast_factor = Region_Diet,
                 results_combinations = NA,
                 use_IHW_filtering = TRUE,
                 alpha = 0.05,
                 samples_to_remove = NA 
                 )


```


```{r}

############################################################################# #
#Method to access lowest level of list, in this case Pvalue_histograms.
#make a function for this
fake_output <- list(LHA_DESeq2_Output = DE_out$ARC_DESeq2_Output, ARC_DESeq2_Output = DE_out$ARC_DESeq2_Output )


test<- fake_output %>% 
  unlist(recursive = F) %>% 
  {.[grepl("pairwise_plots", names(.))]}

test2 <- test %>% 
  unlist(recursive = FALSE) %>% 
  {.[grepl("Pvalue_histogram", names(.))]}


test3 <- test %>% 
  unlist(recursive = FALSE) %>% 
  {.[grepl("MA_plots", names(.))]}



test2 %>% 
  purrr::map(function(x){
  plot.new()
    print(x)
})
############################################################################# #


fake_output <- list(LHA_DESeq2_Output = DE_out$ARC_DESeq2_Output, ARC_DESeq2_Output = DE_out$ARC_DESeq2_Output )

test <- fake_output %>% 
  unlist(recursive = FALSE)
test$LHA_DESeq2_Output.DESeq2_res_object$

```


# 4. Function combined DESEQ2 
Old code used calls to teh dds object, not the dds_wald object, which is produced after call to DESeq()
However, tests show dds and dds_wald have exact same output
```{r}

norm_out <- .norm_and_plot(dds_object = DE_out$ARC_DESeq2_Output$dds_wald_object,
               gene_annotations = test_annot,
               export_tables = FALSE,
               top_level_filter = Region)

norm_out #need to add names to list output!!


#function for normalisation and plotting - to use internally within each deseq run for each region

```



#Working
Subset se object before converting dds (as dds should be in function as split by region.)



a character vector with exactly three elements: the name of a factor in the design formula, the name of the numerator level for the fold change, and the name of the denominator level for the fold change (simplest case)
```{r}

full_dataset_DE <- plyr::ldply(pairwise_contrasts$df_pairwise_name, 
                        function(x) {
                          .pairwise_df <- dplyr::filter(pairwise_contrasts, df_pairwise_name == x)
                          #the following code could probably use ldply too? as it completes rbind.fill within
                          df <- do.call("rbind.fill",
                                        lapply(.pairwise_df$df_pairwise_name,
                                               function(x)
                                                 get(x)
                                                 ))#get's the dataframe by name
                          
                          df <- df %>% mutate(import_comparison_id = str_c(region, .pairwise_df$pairwise_short[1], sep = "_"),
                                              import_region = region,
                                              pairwise_short = .pairwise_df$pairwise_short[1],
                                              pairwise_description = .pairwise_df$Long_pairwise_description,
                                              pairwise_long = str_split(pairwise_description, pattern = " - ", simplify = T)[,1],
                                              description_short = str_split(description, pattern = "\\[", simplify = T)[,1]
                                              )
                          df
                          }
                        )


```
# Code for renaming old cts tables
```{r}
#read in count table - hypothalamus

cts_hypo_liv <- data.table::fread("../Sheep_RNAseq/Inputs/featureCounts_hypothalamus-liver.txt", header = T)

colnames(cts_hypo_liv)[1] <- "gene_ensembl"

#rename incorrect entries:
cts_hypo_liv <- cts_hypo_liv %>% 
  dplyr::rename("VMH_21_HCP-HP-UMEI" = "VMH_21_HCP-HP-RMEI", 
                "VMH_02_HCP-LP-UMEI" = "VMH_02_LCP-LP-UMEI")


#rename LAT to LHA
colnames(cts_hypo_liv) <- stringr::str_replace_all(string = names(cts_hypo_liv), pattern = "LAT", replacement = "LHA")

#find actual sample names from table
selection <- match(colnames(cts_hypo_liv)[-1], coldata[["rowname"]] ) %>% purrr::discard(is.na)

new_names <- coldata[selection,]$sample_names
colnames(cts_hypo_liv)[-1] <- new_names

selection <- match(colnames(cts_hypo_liv)[-1], coldata[["rowname"]] ) %>% purrr::discard(is.na)
all((temp1[["rowname"]]== colnames(cts_hypo_liv)[-1] ))


#read in count table - GIT & ST
cts_git_st <- data.table::fread("../Sheep_RNAseq/Inputs/featureCounts_matrix_DUO_RUM_ST_20200901.tabular") %>% 
  dplyr::select(!contains("ST"))

colnames(cts_git_st)[1] <- "gene_ensembl"


selection <- match(colnames(cts_git_st)[-1], coldata[["rowname"]] ) %>% purrr::discard(is.na)
temp1 <- coldata[selection,]
all(temp1[["rowname"]] == colnames(cts_git_st)[-1] )

new_names <- temp1$sample_names
colnames(cts_git_st)[-1] <- new_names
#Join cts together

cts_all <- dplyr::full_join(cts_hypo_liv, cts_git_st)

colnames(cts_all)
```

#testing
```{r}

f_test <- function (res_out, top_level_filter = "ARC"){
  

}

f_test(output)


```

