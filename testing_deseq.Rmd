---
title: "Testing DESEQ2"
output: html_notebook
---

Iteration of DESEQ2 over: Region level, then treatment comparison

Region level - e.g. Tissue region, indicates all DE data from same tissue and experiment. These are analysed independently from every other region.

Within a region, the treatments are compared.


However, for downstream plotting, the normalised data from all regions is calculated. Particularly important for co-expression related analysis.


To normalise gene expression across all tissues, the 'DESEQ2 - all tissues - FULL - **' needs to be used.

#Step 1a in pipeline

# 1. Import metadata
```{r}

#import data about columns, that is each column should be metadata about the sample/animal. Particularly include all treatment info and animal ID in columns. 
coldata <-  data.table::fread(file = "../Sheep_RNAseq/Inputs/coldata_new_names_20201105.csv") %>% 
  dplyr::mutate(sample_names = paste0(Region, "_", ID, "__", Diet))

#coldata <-  data.table::fread(file = "./coldata_test.csv") %>% 
 # dplyr::mutate(sample_names = paste0(Region, "_", ID, "__", Diet))


```




# 2. import all count tables and join
TODO - make it handle when too many names are in coldata compared to cts_all
Error: Can't subset columns that don't exist.
x Columns `BONE_8__Feed`, `BONE_20__Fast`, and `BONE_15__Refeed` don't exist.
```{r matrix_input, echo=T}


cts_all <- data.table::fread(file= "./cts_renamed_all_Sheep.txt")

###### ************
# Use new function
cts_filtered <- check_count_matrix(count_data = cts_all, 
                            colData = coldata,
                            column_with_col_names = sample_names
                            )

# filter colData, as suggested by above
coldata <- subset_colData(count_data = cts_all, 
                            colData = coldata,
                            column_with_col_names = sample_names)

#re-run check
cts_filtered <- check_count_matrix(count_data = cts_all, 
                            colData = coldata,
                            column_with_col_names = sample_names
                            )
#rm(cts_all)
```



# 3. convert ensemble ID to gene ID

```{r}

test_annot <- annotate_gene_ensembl(cts_filtered, organism = "oaries")


#used without internet connection
# temp <- data.table::fread(file="./outputs/normalised_counts/ARC_VST_normalisedcounts_20211117_1638.txt")
# test_annot <- temp %>% dplyr::select(gene_ensembl, gene_name, description)
# test_annot <- cts_filtered %>% 
#   dplyr::select(gene_ensembl) %>% 
# dplyr::left_join(test_annot)
```


# Prepare data
TO DO: make a wrapper for this with specific checks of data / auto matrix
```{r}

test_data <-
  SummarizedExperiment::SummarizedExperiment(
    assays = cts_filtered %>% 
      tibble::column_to_rownames(var = "gene_ensembl") %>% 
      as.matrix(),
    rowData = test_annot, 
    colData = coldata)

#subset columns to be every n, to make testing quicker
test_data <- test_data[,seq(0,ncol(cts_filtered)-1,4)] 


```



#4. Generate DE results
TO DO: - detect all options for 'top_level_filter' and parse to map().

```{r}

DE_out <- 
  purrr::map(.x = list("LIV", "ARC"),
             .f = auto_generate_DE_results, 
             se_data = test_data,
             top_level_name = Region,
             column_of_samples = sample_names,
             samples_to_remove = NA,
             DESeq2_formula_design = ~Region_Diet,
             rowSums_filter = 10, #for dds filtering
             results_contrast_factor = Region_Diet,
             results_combinations = NA,
             use_IHW_filtering = TRUE,
             alpha = 0.05,
             gene_annotations = test_annot,
             export_tables = TRUE,
             export_dir = "./outputs/")


```

#5. Accessing results
TO DO: 
```{r}
#unlist to take away the un-named, top layer. Gives access via $
DE_out2 <- DE_out %>% unlist(recursive = FALSE)


DE_out2$ARC_DESeq2_Output$PIF$
#{.[grepl("MA_plots", names(.))]}
```

## Accessing sorted DE Tables - pre-PIF
```{r}
DE_out_test$LIV_DESeq2_Output$DESeq2_annot_df

```
# Normalise accross whole dataset (not each top_level/region)
```{r}
full_norm <- 
  auto_generate_DE_results(
             se_data = test_data,
             top_level_name = Region,
             column_of_samples = sample_names,
             samples_to_remove = NA,
             DESeq2_formula_design = ~Region_Diet,
             gene_annotations = test_annot,
             export_tables = TRUE,
             export_dir = "./outputs/",
             whole_data_normalisation = TRUE)


 top_level_filter <- "Whole_Dataset"

  
 vsd <- DESeq2::vst(dds_wald, blind=FALSE)
 
  
 #results_contrast_factor_string <- "Region"
 
 f_test <- function(top_level_name = Region){
   results_contrast_factor_string <- rlang::enquo(top_level_name) %>% rlang::as_label()
 pcaData <- DESeq2::plotPCA(vsd, intgroup=c(results_contrast_factor_string), returnData=TRUE, ntop = 500)
pcaData
 }
 
 f_test()
 
  percentVar <- round(100 * attr(pcaData, "percentVar"))

  PCA_plot <- ggplot2::ggplot(pcaData, ggplot2::aes(.data$PC1, .data$PC2, fill=Region)) +
    ggplot2::geom_point(size=4.2, shape = 21, colour = "black", alpha = 0.8) +
    ggplot2::xlab(paste0("PC1: ",percentVar[1],"% variance")) +
    ggplot2::ylab(paste0("PC2: ",percentVar[2],"% variance")) +
    ggplot2::coord_fixed()+
    #coord_fixed(xlim = c(-150,150), ylim = c(-120, 120)) +
    ggplot2::theme_classic()+
    ggrepel::geom_text_repel(mapping = ggplot2::aes(label=.data$name), max.overlaps = 10)+
    ggplot2::ggtitle(label = paste(top_level_filter))
 
 
 norm_out <- .norm_and_plot(top_level_filter = NA,
                             dds_object = dds_wald,
                             gene_annotations = test_annot,
                             export_tables = TRUE,
                             export_dir = "./outputs/",
                             results_contrast_factor = "test",
                             whole_data_normalisation = TRUE,
                             top_level_name = Region)
  #accesses two separate parts of output, which already contain the region name in them so are unique
  overall_plots_list <- norm_out[grepl("overall_plots", names(norm_out))][[1]]
  normalised_data_list <- norm_out[grepl("normalised_data", names(norm_out))][[1]]
  
  
    #export tables of VST and log2 normalised data, plus the full list of DE output
  
  
  f_test <- 
    function(export_tables = TRUE,
             export_dir = "./outputs/"){
      f_test2 <- 
        function(export_tables,
               export_dir){
        if(export_tables == TRUE){
          print("1")
         print(dir.exists(export_dir))
        }
        }
      f_test2(export_tables,
              export_dir)    
    }

  f_test(export_tables = TRUE,
         export_dir = "./outputs/")  

```


# g:Profiler search for GO Terms
Take all DE genes as input to an pathway enrichment analysis using g:Profiler API
This is the same as copy and paste each list of DE genes into the "Functional Profiling" box at https://biit.cs.ut.ee/gprofiler/

```{r}

```




#Workign
```{r}
#testing how many have real names
 x %>% 
        as.data.frame() %>% 
        tibble::rownames_to_column(var = "gene_ensembl") %>%
        dplyr::left_join(annot, by = c("gene_ensembl")) %>%
        dplyr::select(.data$gene_ensembl,
                      .data$gene_name,
                      .data$description,
                      tidyselect::everything()) %>% 
        arrange(.data$padj)
```

## Code for renaming old cts tables
```{r eval=FALSE, include=FALSE}
#read in count table - hypothalamus

cts_hypo_liv <- data.table::fread("../Sheep_RNAseq/Inputs/featureCounts_hypothalamus-liver.txt", header = T)

colnames(cts_hypo_liv)[1] <- "gene_ensembl"

#rename incorrect entries:
cts_hypo_liv <- cts_hypo_liv %>% 
  dplyr::rename("VMH_21_HCP-HP-UMEI" = "VMH_21_HCP-HP-RMEI", 
                "VMH_02_HCP-LP-UMEI" = "VMH_02_LCP-LP-UMEI")


#rename LAT to LHA
colnames(cts_hypo_liv) <- stringr::str_replace_all(string = names(cts_hypo_liv), pattern = "LAT", replacement = "LHA")

#find actual sample names from table
selection <- match(colnames(cts_hypo_liv)[-1], coldata[["rowname"]] ) %>% purrr::discard(is.na)

new_names <- coldata[selection,]$sample_names
colnames(cts_hypo_liv)[-1] <- new_names

selection <- match(colnames(cts_hypo_liv)[-1], coldata[["rowname"]] ) %>% purrr::discard(is.na)
all((temp1[["rowname"]]== colnames(cts_hypo_liv)[-1] ))


#read in count table - GIT & ST
cts_git_st <- data.table::fread("../Sheep_RNAseq/Inputs/featureCounts_matrix_DUO_RUM_ST_20200901.tabular") %>% 
  dplyr::select(!contains("ST"))

colnames(cts_git_st)[1] <- "gene_ensembl"


selection <- match(colnames(cts_git_st)[-1], coldata[["rowname"]] ) %>% purrr::discard(is.na)
temp1 <- coldata[selection,]
all(temp1[["rowname"]] == colnames(cts_git_st)[-1] )

new_names <- temp1$sample_names
colnames(cts_git_st)[-1] <- new_names
#Join cts together

cts_all <- dplyr::full_join(cts_hypo_liv, cts_git_st)

colnames(cts_all)
```

